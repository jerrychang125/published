%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%>
% Generate the dense grid of convolutional descriptors for each
% image (based on their feature maps). This is done by pooling each feature map
% by the specified factor and type (first dessimating them into patches). Then 
% grouping each pooled map into small regions to and using such regions over
% all the maps to form a descriptor.
%
% Based on code by Svetlana Lazebnik for Spatial Pyramid Matching.
%
% @file
% @author Svetlana Lazebnik
% @author Matthew Zeiler
% @date Mar 11, 2010
%
% @spm_file @copybrief GenerateConvDescriptors.m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%>
% @copybrief GenerateConvDescriptors.m
%
% @param imageFileList cell of file paths
% @param trainimageBaseDir the base directory for the training image files
% @param testimageBaseDir the base directory for the testing image files
% @param train_test_split the number of training images.
% @param dataBaseDir the base directory for the data files that are generated by the algorithm. If this dir is the same as imageBaseDir the files will be generated in the same location as the image files
% @param maxImageSize the max plane size. (not implemented here).
% @param gridSpacing the spacing for the grid to be used when generating the sift descriptors
% @param patchSize the patch size used for generating the sift descriptor
% @param poolSize the amount to pool the image patches down before collecting them on the grid of pooled pixels.
% @param gridSize the size of the regions on the pooled maps to collect x the number of pooled maps gives the size of the descriptor.
% @param cropSize the size of the crop region to take out of the middle of each feature map.
% @param canSkip if true the calculation will be skipped if the appropriate data
% file is found in dataBaseDir. This is very useful if you just want to update
% some of the data or if you've added new images.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function [] = GenerateConvDescriptors( imageFileList, trainimageBaseDir, testimageBaseDir, train_test_split, dataBaseDir, maxImageSize, gridSpacing, patchSize, poolSize, poolType, gridSize, cropSize, canSkip )

fprintf('Building Convolutional Descriptors\n\n');

%% parameters

if(nargin<6)
    maxImageSize = 1000
end

if(nargin<7)
    gridSpacing = 8
end

if(nargin<8)
    patchSize = 16
end

if(nargin<9)
    poolSize = [4 4]
end

if(nargin<10)
    poolType = 'Avg'
end

if(nargin<11)
    gridSize = [4 4]
end

if(nargin<12)
    cropSize = [150 150]
end

if(nargin<13)
    canSkip = 0
end




for f = 1:size(imageFileList,1)
    
    %% load image
    imageFName = imageFileList{f};
    [dirN base] = fileparts(imageFName);
    baseFName = [dirN filesep base];
    outFName = fullfile(dataBaseDir, sprintf('%s_sift.mat', baseFName));
    if(f<=train_test_split)
        imageFName = fullfile(trainimageBaseDir, imageFName);
    else
        imageFName = fullfile(testimageBaseDir, imageFName);
    end
    %     imageFName = fullfile(imageBaseDir, imageFName);
    
    if(size(dir(outFName),1)~=0 && canSkip)
        fprintf('GenerateConvDescriptors Skipping %s\n', imageFName);
        continue;
    end
    
    % Loads the .mat file containing feature maps z.
    load(imageFName);
    I = z;
    
    %% make grid (coordinates of upper left patch corners just for staying consistent with her format)
    [hgt wid blah] = size(I);
    % Get the size the Svetlana's code will see (no CN or filter
    % convolved over the image).
    [xdim ydim blah blah2] = size(y);
    
    % Have to get rid of the effect of CN and convolutions changing the
    % size of the original image (crop the center portion).
    xdim = cropSize(1);
    ydim = cropSize(2);
    otheroffX = floor(abs(xdim-hgt)/2);
    otheroffY = floor(abs(ydim-wid)/2);
    I = I(otheroffX+1:end-otheroffX,otheroffY+1:end-otheroffY,:,:);
    [hgt wid blah] = size(I);
    
    
    if(strcmp(poolType,'Abs') || strcmp(poolType,'None'))
        remX = mod(wid-patchSize,gridSpacing*(gridSize(1)/(patchSize/1)));
        offsetX = floor(remX/2)+1;
        remY = mod(hgt-patchSize,gridSpacing*(gridSize(2)/(patchSize/1)));
        offsetY = floor(remY/2)+1;
        [gridX,gridY,blah] = meshgrid(offsetX:gridSpacing*(gridSize(1)/(patchSize/1)):wid-patchSize+1, offsetY:gridSpacing*(gridSize(2)/(patchSize/1)):hgt-patchSize+1,1);
    else
        remX = mod(wid-patchSize,gridSpacing*(gridSize(1)/(patchSize/poolSize(1))));
        offsetX = floor(remX/2)+1;
        remY = mod(hgt-patchSize,gridSpacing*(gridSize(2)/(patchSize/poolSize(2))));
        offsetY = floor(remY/2)+1;
        [gridX,gridY,blah] = meshgrid(offsetX:gridSpacing*(gridSize(1)/(patchSize/poolSize(1))):wid-patchSize+1, offsetY:gridSpacing*(gridSize(2)/(patchSize/poolSize(2))):hgt-patchSize+1,1);
    end
    fprintf('Processing %d/%d %s: wid %d, hgt %d, grid size: %d x %d, %d patches\n', ...
        f,size(imageFileList,1),imageFName, wid, hgt, size(gridX,2), size(gridX,1), numel(gridX));
    
    % Get the overlapping patches and spread them out into a large image.
    if(patchSize == gridSpacing(1))
        patchedI = I;
    else
        patchedI = dessimate_spread(I,patchSize,gridSpacing,gridSize,poolSize);
    end
    
    % Pool the
    switch poolType
        case 'Max'
            pooled_features = max_pool(patchedI,poolSize);
        case 'Avg'
            pooled_features = avg_pool(patchedI,poolSize);
        case 'Abs_Avg'
            pooled_features = abs_avg_pool(patchedI,poolSize);
        case 'Max_Abs'
            pooled_features = abs(max_pool(patchedI,poolSize));
        case 'Abs'
            pooled_features = abs(patchedI);
        case 'None'
            pooled_features = patchedI;
    end
    
    
    % Collect the descriptors for the current image.
    % Can use the same normalization of the descriptors as Svetlana.
    features.data = make_descriptors(pooled_features,gridSize);
    %             figure(100)
    %     hist(features.data(:),100)
    %     title('Mine before rescale_row_0_1')
    
    features.data = rescale_row_0_1(features.data);
    %             figure(101)
    %     hist(features.data(:),100)
    %     title('Mine before normalizing')
    features.data = sp_normalize_sift(features.data);
    %
    %         figure(102)
    %     hist(features.data(:),100)
    %     title('Mine after normalizing')
    %     keyboard
    
    % Have to compute a special offset for the locations of the centers of the patches.
    offset = 0;
    for i=1:max((gridSize(1)/(patchSize/poolSize(1))),1)
        offset = offset + (i-1)*gridSpacing + patchSize/2;
    end
    % The offset should be the average of these offsets.
    offset = offset/max((gridSize(1)/(patchSize/poolSize(1))),1);
    
    % gridX = gridX + offset;
    % gridY = gridY + offset;
    %     if(size(gridX,1)*size(gridX,2) ~= size(features.data,1))
    %         index = size(gridX,2);
    %         while(any(any(gridX + offset -0.5 > xdim -floor(patchSize/2))))
    %             gridX = gridX(:,1:index-1);
    %             gridY = gridY(:,1:index-1);
    %             index = index - 1;
    %         end
    %         index = size(gridY,1);
    %         while(any(any(gridY + offset -0.5 > ydim -floor(patchSize/2))))
    %             gridX = gridX(1:index-1,:);
    %             gridY = gridY(1:index-1,:);
    %             index = index - 1;
    %         end
    %     end
    
    %% Usually off by one on the grid size (smaller) so make it one bigger in
    %% each direction.
    while(size(gridX,1)*size(gridX,2) < size(features.data,1))
        %         index = size(gridX,2);
        gridX(:,end+1) = gridX(:,end);
        gridX(end+1,:) = gridX(end,:);
        gridY(end+1,:) = gridY(end,:);
        gridY(:,end+1) = gridY(:,end);
        %         while(any(any(gridX + offset -0.5 > xdim -floor(patchSize/2))))
        %             gridX( = gridX(:,1:index-1);
        %             gridY = gridY(:,1:index-1);
        %             index = index - 1;
        %         end
        %         index = size(gridY,1);
        %         while(any(any(gridY + offset -0.5 > ydim -floor(patchSize/2))))
        %             gridX = gridX(1:index-1,:);
        %             gridY = gridY(1:index-1,:);
        %             index = index - 1;
        %         end
    end
    
    if(size(gridX,1)*size(gridX,2) ~= size(features.data,1))
        index = size(gridX,2);
        while(any(any(gridX + offset -0.5 > xdim -floor(patchSize/2))))
            gridX = gridX(:,1:index-1);
            gridY = gridY(:,1:index-1);
            index = index - 1;
        end
        index = size(gridY,1);
        while(any(any(gridY + offset -0.5 > ydim -floor(patchSize/2))))
            gridX = gridX(1:index-1,:);
            gridY = gridY(1:index-1,:);
            index = index - 1;
        end
    end
    
    % if(size(gridX,1) < size(gridX,2))
    %     gridX = gridX(:,1:size(gridX,1));
    % elseif(size(gridX,1) > size(gridX,2))
    %     gridX = gridY(1:size(gridX,2),:);
    % end
    %    if(size(gridY,1) < size(gridY,2))
    %     gridY = gridY(:,1:size(gridY,1));
    % elseif(size(gridY,1) > size(gridY,2))
    %     gridY = gridY(1:size(gridY,2),:);
    % end
    
    % gridX = gridX(gridX +offset - 0.5 < xdim - floor(patchSize/2));
    % gridY = gridY(gridY +offset - 0.5 < ydim - floor(patchSize/2));
    
    
    %% Try from scratch to get the proper grid spacing.
    % [gridX,gridY] = meshgrid(offsetX:gridSpacing:wid-patchSize+1, offsetY:gridSpacing:hgt-patchSize+1);
    % avg_num = gridSize(1)/(patchSize/poolSize(1));
    
    features.x = gridX(:) + offset - 0.5;
    %     features.x = features.x(features.x < xdim - floor(patchSize/2));
    features.y = gridY(:) + offset - 0.5;
    %         features.y = features.y(features.y < xdim - floor(patchSize/2));
    
    features.wid = wid;
    features.hgt = hgt;
    
    
    if(size(features.x,1) ~= size(features.data,1))
        error('In GenerateConvDescriptors the dimensions dont match')
    end
    %         keyboard
    
    
    sp_make_dir(outFName);
    save(outFName, 'features');
    
end % for

end % function
